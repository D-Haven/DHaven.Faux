using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace DHaven.Faux.Compiler
{
    public class HystrixWebServiceClassGenerator : IWebServiceClassGenerator
    {
        public CompilerConfig Config { get; }

        private readonly ILogger<CoreWebServiceClassGenerator> logger;
        private readonly IMethodClassGenerator methodGenerator;
        
        public HystrixWebServiceClassGenerator(IOptions<CompilerConfig> options, IMethodClassGenerator methodClassGenerator, ILogger<CoreWebServiceClassGenerator> logger)
        {
            // This is temporary until I get the FauxServiceProvider working for options.
            Config = options?.Value ?? new CompilerConfig();
            this.logger = logger;            
            methodGenerator = methodClassGenerator;

            if (string.IsNullOrEmpty(Config.RootNamespace))
            {
                Config.RootNamespace = "DHaven.Feign.Wrapper";
            }

            if (string.IsNullOrEmpty(Config.SourceFilePath))
            {
                Config.SourceFilePath = "./dhaven-faux";
            }

            if (!Directory.Exists(Config.SourceFilePath))
            {
                Directory.CreateDirectory(Config.SourceFilePath);
            }
        }

        public IEnumerable<string> GenerateSource(TypeInfo typeInfo, out string fullClassName)
        {
            if (!typeInfo.IsInterface || !typeInfo.IsPublic)
            {
                throw new ArgumentException($"{typeInfo.FullName} must be a public interface");
            }

            if (typeInfo.IsGenericType)
            {
                throw new NotSupportedException($"Generic interfaces are not supported: {typeInfo.FullName}");
            }

            var className = typeInfo.FullName?.Replace(".", string.Empty);
            fullClassName = $"{Config.RootNamespace}.{className}";
            var sourceCodeList = new List<string>();

            using (logger.BeginScope("Generator {0}:", className))
            {
                var serviceName = typeInfo.GetCustomAttribute<FauxClientAttribute>().Name;
                var baseRoute = typeInfo.GetCustomAttribute<FauxClientAttribute>().Route ?? string.Empty;
                var fallbackClass = typeInfo.GetCustomAttribute<HystrixFauxClientAttribute>().Fallback;
                var sealedString = Config.GenerateSealedClasses ? "sealed" : string.Empty;

                logger.LogTrace("Beginning to generate source");

                using (var namespaceBuilder = new IndentBuilder())
                {
                    namespaceBuilder.AppendLine($"namespace {Config.RootNamespace}");
                    namespaceBuilder.AppendLine("{");
                    using (var classBuilder = namespaceBuilder.Indent())
                    {
                        classBuilder.AppendLine("// Generated by DHaven.Faux");
                        classBuilder.AppendLine(
                            $"public {sealedString} class {className} : DHaven.Faux.HttpSupport.DiscoveryAwareBase, {typeInfo.FullName}");
                        classBuilder.AppendLine("{");
                        
                        using (var fieldBuilder = classBuilder.Indent())
                        {
                            fieldBuilder.AppendLine("private readonly Microsoft.Extensions.Logging.ILogger 仮logger;");
                            fieldBuilder.AppendLine($"private readonly {typeInfo.FullName} 仮fallback;");
                            fieldBuilder.AppendLine("private readonly Steeltoe.CircuitBreaker.Hystrix.IHystrixCommandGroupKey 仮groupKey;");
                        }

                        using (var constructorBuilder = classBuilder.Indent())
                        {
                            constructorBuilder.AppendLine($"public {className}(DHaven.Faux.HttpSupport.IHttpClient client,");
                            constructorBuilder.AppendLine("        Microsoft.Extensions.Logging.ILogger logger)");
                            constructorBuilder.AppendLine($"    : base(client, \"{serviceName}\", \"{baseRoute}\")");
                            constructorBuilder.AppendLine("{");
                            using (var insideCxrBuilder = constructorBuilder.Indent())
                            {
                                insideCxrBuilder.AppendLine("仮logger = logger;");
                                if (fallbackClass != null)
                                {
                                    insideCxrBuilder.AppendLine($"仮fallback = new {CompilerUtils.ToCompilableName(fallbackClass)}();");
                                }
                                insideCxrBuilder.AppendLine(
                                    $"仮groupKey = Steeltoe.CircuitBreaker.Hystrix.HystrixCommandGroupKeyDefault.AsKey(\"{serviceName}\");");
                            }

                            constructorBuilder.AppendLine("}");
                        }

                        foreach (var method in typeInfo.GetMethods())
                        {
                            sourceCodeList.Add(methodGenerator.GenerateMethodClass(method, out var hystrixCommandName));
                            BuildMethod(classBuilder.Indent(), method, hystrixCommandName);
                        }

                        classBuilder.AppendLine("}");
                    }

                    namespaceBuilder.AppendLine("}");

                    var sourceCode = namespaceBuilder.ToString();

                    logger.LogTrace("Source generated");

                    if (Config.OutputSourceFiles)
                    {
                        var fullPath = Path.Combine(Config.SourceFilePath, $"{className}.cs");
                        try
                        {
                            logger.LogTrace("Writing source file: {0}", fullPath);
                            File.WriteAllText(fullPath, sourceCode, Encoding.UTF8);
                        }
                        catch (Exception ex)
                        {
                            logger.LogWarning(ex, "Could not write the source code for {0}", fullPath);
                        }
                    }

                    sourceCodeList.Add(sourceCode);
                    return sourceCodeList;
                }
            }
        }
 
        private void BuildMethod(IndentBuilder classBuilder, MethodInfo method, string hystrixCommandName)
        {
            var isAsyncCall = typeof(Task).IsAssignableFrom(method.ReturnType);
            var returnType = method.ReturnType;

            if(isAsyncCall && method.ReturnType.IsConstructedGenericType)
            {
                returnType = method.ReturnType.GetGenericArguments()[0];
            }

            var isVoid = returnType == typeof(void) || (isAsyncCall && !method.ReturnType.IsConstructedGenericType);

            // Write the method declaration

            classBuilder.Append("public ");
            if (isAsyncCall)
            {
                classBuilder.Append("async ");
                classBuilder.Append(typeof(Task).FullName);

                if(!isVoid)
                {
                    classBuilder.Append($"<{CompilerUtils.ToCompilableName(returnType)}>");
                }
            }
            else
            {
                classBuilder.Append(isVoid ? "void" : CompilerUtils.ToCompilableName(returnType));
            }

            classBuilder.Append($" {method.Name}(");
            classBuilder.Append(string.Join(", ", method.GetParameters().Select(CompilerUtils.ToParameterDeclaration)));
            classBuilder.AppendLine(")");
            classBuilder.AppendLine("{");
            using (var methodBuilder = classBuilder.Indent())
            {
                methodBuilder.Append($"var 仮command = new {hystrixCommandName}(this, 仮fallback, ");
                
                foreach (var inParam in method.GetParameters().Where(p => !p.IsOut))
                {
                    methodBuilder.Append($"{CompilerUtils.ToParameterUsage(inParam)}, ");
                }

                methodBuilder.AppendLine(" 仮logger);");

                methodBuilder.Append(isVoid ? string.Empty : "var 仮value = ");
                methodBuilder.AppendLine(isAsyncCall
                    ? "await 仮command.ExecuteAsync();"
                    : "仮command.Execute();");

                foreach (var outParam in method.GetParameters().Where(p => p.IsOut))
                {
                    methodBuilder.AppendLine($"{outParam.Name} = 仮command.{outParam.Name};");
                }

                if (!isVoid)
                {
                    methodBuilder.AppendLine("return 仮value;");
                }
            }

            classBuilder.AppendLine("}");
        }
    }
}