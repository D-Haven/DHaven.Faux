#region Copyright 2017 D-Haven.org

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#endregion

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using TypeInfo = System.Reflection.TypeInfo;
using System.Threading.Tasks;
using System.Net.Http;
using Microsoft.Extensions.Logging;

namespace DHaven.Faux.Compiler
{
    internal class WebServiceComplier
    {
        private const string RootNamespace = "DHaven.Feign.Wrapper";
        private readonly TypeInfo typeInfo;
        private readonly string newClassName;
        private static Assembly servicesAssembly;
        private static readonly List<SyntaxTree> SyntaxTrees = new List<SyntaxTree>();

        private static readonly ISet<string> References = new HashSet<string>();

        static WebServiceComplier()
        {
            var faux = DiscoverySupport.Configuration.GetSection("faux");
            var debug = faux.GetSection("debug");

            OutputSourceFiles = Convert.ToBoolean(debug["outputSource"]);
            SourceFilePath = debug["sourcePath"];

            if (string.IsNullOrEmpty(SourceFilePath))
            {
                SourceFilePath = "./dhaven-faux";
            }

            if (!Directory.Exists(SourceFilePath))
            {
                Directory.CreateDirectory(SourceFilePath);
            }
        }

        protected WebServiceComplier(TypeInfo type)
        {
            typeInfo = type;
            newClassName = $"{RootNamespace}.{typeInfo.FullName?.Replace(".", string.Empty)}";
            UpdateReferences(GetType().GetTypeInfo().Assembly);
            UpdateReferences(typeInfo.Assembly);
            Define();
        }

        public static bool OutputSourceFiles { get; }
        public static string SourceFilePath { get; }

        private void UpdateReferences(Assembly assembly)
        {
            string referenceLocation = assembly.Location;

            if (!References.Contains(referenceLocation))
            {
                References.Add(referenceLocation);

                foreach(var dependency in assembly.GetReferencedAssemblies())
                {
                    UpdateReferences(Assembly.Load(dependency));
                }
            }
        }

        public void Define()
        {
            if (!typeInfo.IsInterface || !typeInfo.IsPublic)
            {
                throw new ArgumentException($"{typeInfo.FullName} must be a public interface");
            }

            if (typeInfo.IsGenericType)
            {
                throw new NotSupportedException($"Generic interfaces are not supported: {typeInfo.FullName}");
            }

            var className = typeInfo.FullName?.Replace(".", string.Empty);
            var serviceName = CustomAttributeExtensions.GetCustomAttribute<FauxClientAttribute>(typeInfo).Name;
            var baseRoute = CustomAttributeExtensions.GetCustomAttribute<RouteAttribute>(typeInfo).BaseRoute;

            var classBuilder = new StringBuilder();
            classBuilder.AppendLine($"namespace {RootNamespace}");
            classBuilder.AppendLine("{");
            classBuilder.AppendLine("    // Generated by DHaven.Faux");
            classBuilder.AppendLine($"    public class {className} : DHaven.Faux.Compiler.DiscoveryAwareBase, {typeInfo.FullName}");
            classBuilder.AppendLine("    {");
            classBuilder.AppendLine($"        public {className}()");
            classBuilder.AppendLine($"            : base(\"{serviceName}\", \"{baseRoute}\") {{ }}");

            foreach(var method in typeInfo.GetMethods())
            {
                BuildMethod(classBuilder, method);
            }

            classBuilder.AppendLine("    }");
            classBuilder.AppendLine("}");

            var sourceCode = classBuilder.ToString();

            if (OutputSourceFiles)
            {
                var fullPath = Path.Combine(SourceFilePath, className + ".cs");
                try
                {
                    File.WriteAllText(fullPath, sourceCode, Encoding.UTF8);
                }
                catch(Exception ex)
                {
                    DiscoverySupport.Logger.LogWarning(ex, "Could not write the source code for {0}", fullPath);
                }
            }

            SyntaxTrees.Add(SyntaxFactory.ParseSyntaxTree(sourceCode));
        }

        public object Generate()
        {
            if (servicesAssembly == null)
            {
                Compile();
                Debug.Assert(servicesAssembly != null);
            }

            var type = servicesAssembly.GetType(newClassName);
            var constructor = type.GetConstructor(new Type[0]);
            return constructor?.Invoke(new object[0]);
        }

        private void BuildMethod(StringBuilder classBuilder, MethodInfo method)
        {
            var isAsyncCall = typeof(Task).IsAssignableFrom(method.ReturnType);
            var returnType = method.ReturnType;

            if(isAsyncCall && method.ReturnType.IsConstructedGenericType)
            {
                returnType = method.ReturnType.GetGenericArguments()[0];
            }

            bool isVoid = returnType == typeof(void);

            // Write the method declaration

            classBuilder.Append("        public ");
            if (isAsyncCall)
            {
                classBuilder.Append("async ");
                classBuilder.Append(typeof(Task).FullName);

                if(!isVoid)
                {
                    classBuilder.Append($"<{ToCompilableName(returnType)}>");
                }
            }
            else
            {
                classBuilder.Append(isVoid ? "void" : ToCompilableName(returnType));
            }

            var attribute = CustomAttributeExtensions.GetCustomAttribute<HttpMethodAttribute>(method);

            classBuilder.Append($" {method.Name}(");
            classBuilder.Append(string.Join(", ", method.GetParameters().Select(p => $"{ToCompilableName(p.ParameterType)} {p.Name}")));
            classBuilder.AppendLine(")");
            classBuilder.AppendLine("        {");
            classBuilder.AppendLine("            var 仮variables = new System.Collections.Generic.Dictionary<string,object>();");
            classBuilder.AppendLine("            var 仮reqParams = new System.Collections.Generic.Dictionary<string,string>();");

            var contentHeaders = new Dictionary<string, ParameterInfo>();
            var requestHeaders = new Dictionary<string, ParameterInfo>();
            var responseHeaders = new Dictionary<string, ParameterInfo>();
            ParameterInfo bodyParam = null;
            BodyAttribute bodyAttr = null;

            foreach (var parameter in method.GetParameters())
            {
                AttributeInterpreter.InterpretPathValue(parameter, classBuilder);

                AttributeInterpreter.InterpretRequestHeader(parameter, requestHeaders, contentHeaders);

                AttributeInterpreter.InterpretBodyParameter(parameter, ref bodyParam, ref bodyAttr);

                AttributeInterpreter.InterpretRequestParameter(parameter, classBuilder);

                AttributeInterpreter.InterpretResponseHeaderInParameters(parameter, isAsyncCall, ref responseHeaders);
            }

            classBuilder.AppendLine($"            var 仮request = CreateRequest({ToCompilableName(attribute.Method)}, \"{attribute.Path}\", 仮variables, 仮reqParams);");
            var hasContent = AttributeInterpreter.CreateContentObjectIfSpecified(bodyAttr, bodyParam, classBuilder);

            foreach (var entry in requestHeaders)
            {
                classBuilder.AppendLine($"            仮request.Headers.Add(\"{entry.Key}\", {entry.Value.Name}{(entry.Value.ParameterType.IsClass ? "?" : "")}.ToString());");
            }

            if (hasContent)
            {
                // when setting content we can apply the contentHeaders
                foreach (var entry in contentHeaders)
                {
                    classBuilder.AppendLine($"            仮content.Headers.Add(\"{entry.Key}\", {entry.Value.Name}{(entry.Value.ParameterType.IsClass ? "?" : "")}.ToString());");
                }

                classBuilder.AppendLine("            仮request.Content = 仮content;");
            }

            classBuilder.AppendLine(isAsyncCall
                ? "            var 仮response = await InvokeAsync(仮request);"
                : "            var 仮response = Invoke(仮request);");

            foreach (var entry in responseHeaders)
            {
                classBuilder.AppendLine($"            {entry.Value.Name} = GetHeaderValue<{ToCompilableName(returnType)}>(仮response, \"{entry.Key}\");");
            }

            if (!isVoid)
            {
                var returnBodyAttribute = method.ReturnParameter?.GetCustomAttribute<BodyAttribute>();
                var returnResponseAttribute = method.ReturnParameter?.GetCustomAttribute<ResponseHeaderAttribute>();

                if (returnResponseAttribute != null && returnBodyAttribute != null)
                {
                    throw new WebServiceCompileException($"Cannot have different types of response attributes.  You had [{string.Join(", ", "Body", "ResponseHeader")}]");
                }

                if (returnResponseAttribute != null)
                {
                    AttributeInterpreter.ReturnResponseHeader(returnResponseAttribute, returnType, classBuilder);
                }
                else
                {
                    if (returnBodyAttribute == null)
                    {
                        returnBodyAttribute = new BodyAttribute();
                    }

                    AttributeInterpreter.ReturnContentObject(returnBodyAttribute, returnType, isAsyncCall, classBuilder);
                }
            }

            classBuilder.AppendLine("        }");
        }

        private static string ToCompilableName(HttpMethod method)
        {
            var value = method.Method.First() + method.Method.Substring(1).ToLower();
            return $"System.Net.Http.HttpMethod.{value}";
        }

        public static string ToCompilableName(Type type)
        {
            var baseName = type.FullName;

            if (type.IsConstructedGenericType)
            {
                baseName = baseName?.Substring(0, baseName.IndexOf('`'));
                return $"{baseName}<{string.Join(",", type.GetGenericArguments().Select(ToCompilableName))}>";
            }

            return baseName;
        }

        private static void Compile()
        {
            var assemblyName = Path.GetRandomFileName();

            var compilation = CSharpCompilation.Create(assemblyName)
                .WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary))
                .AddReferences(References.Select(location => MetadataReference.CreateFromFile(location)))
                .AddSyntaxTrees(SyntaxTrees);

            using (var stream = new MemoryStream())
            {
                var result = compilation.Emit(stream);

                if (result.Success)
                {
                    stream.Seek(0, SeekOrigin.Begin);
                    servicesAssembly = AssemblyLoadContext.Default.LoadFromStream(stream);
                    return;
                }

                var failures = result.Diagnostics.Where(diagnostic =>
                    diagnostic.IsWarningAsError ||
                    diagnostic.Severity == DiagnosticSeverity.Error);

                var errorList = new StringBuilder();
                foreach (var diagnostic in failures)
                {
                    errorList.AppendLine($"{diagnostic.Id}: {diagnostic.GetMessage()}");
                }

                throw new CompilationException(errorList.ToString());
            }
        }
    }

    internal class CompilationException : Exception
    {
        public CompilationException(string message) : base(message)
        {}
    }

    internal class WebServiceCompiler<TService> : WebServiceComplier
        where TService : class
    {
        public WebServiceCompiler() : base(typeof(TService).GetTypeInfo()) { }

        public new TService Generate()
        {
            return base.Generate() as TService;
        }
    }
}